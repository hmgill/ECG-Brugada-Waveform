"""Unified data models for Multi-Dataset ECG Classification (Brugada + PTB-XL)."""

from pathlib import Path
from typing import Optional, Dict, Union, List, Any
from enum import Enum
import ast

import torch
import numpy as np
from pydantic import BaseModel, Field, field_validator, ConfigDict


class DatasetSource(str, Enum):
    """Source of the ECG recording."""
    BRUGADA_HUCA = "brugada_huca"
    PTB_XL = "ptb_xl"


class DiagnosticSuperclass(str, Enum):
    """PTB-XL Diagnostic Superclasses."""
    NORM = "NORM"
    MI = "MI"
    STTC = "STTC"
    CD = "CD"
    HYP = "HYP"
    
    @property
    def description(self) -> str:
        """Returns the full clinical name."""
        mapping = {
            "NORM": "Normal ECG",
            "MI": "Myocardial Infarction",
            "STTC": "ST/T Change",
            "CD": "Conduction Disturbance",
            "HYP": "Hypertrophy"
        }
        return mapping.get(self.value, self.value)


class ECGMetadata(BaseModel):
    """Unified Metadata for Brugada-HUCA and PTB-XL."""
    model_config = ConfigDict(arbitrary_types_allowed=True, extra='ignore')
    
    # Common Identifiers
    patient_id: Union[int, float, str]
    ecg_id: Optional[Union[int, str]] = None
    
    # Source Identification
    dataset_source: DatasetSource = Field(default=DatasetSource.BRUGADA_HUCA)
    
    # Paths
    ecg_signal_path: Optional[Path] = None  # For Brugada-HUCA
    filename_hr: Optional[str] = None        # For PTB-XL (500Hz)
    filename_lr: Optional[str] = None        # For PTB-XL (100Hz)
    
    # Brugada-HUCA Specific Labels
    brugada: Optional[int] = Field(default=None, ge=0, le=2)
    basal_pattern: Optional[int] = Field(default=None)
    sudden_death: Optional[int] = Field(default=None)
    
    # PTB-XL Specific Labels  
    scp_codes: Optional[Union[Dict, str]] = None
    strat_fold: Optional[int] = None
    
    # Inferred Hierarchical Labels
    diagnostic_superclass: List[DiagnosticSuperclass] = Field(default_factory=list)
    diagnostic_subclass: List[str] = Field(default_factory=list)

    @field_validator('scp_codes', mode='before')
    @classmethod
    def parse_scp_codes(cls, v):
        """Parse SCP codes from string representation."""
        if isinstance(v, str):
            try:
                return ast.literal_eval(v)
            except (ValueError, SyntaxError):
                return {}
        return v if v is not None else {}

    @property
    def final_path(self) -> Path:
        """Resolve the path depending on dataset source."""
        if self.dataset_source == DatasetSource.PTB_XL:
            # Prefer 500Hz (hr), fallback to 100Hz (lr)
            path_str = self.filename_hr if self.filename_hr else self.filename_lr
            return Path(str(path_str))
        else:
            return Path(str(self.ecg_signal_path))

    @property
    def diagnosis_readable(self) -> List[str]:
        """Returns human-readable diagnosis strings."""
        readable_labels = [d.description for d in self.diagnostic_superclass]
        
        # Add Brugada if explicitly labeled
        if self.brugada is not None and self.brugada >= 1:
            readable_labels.append("Brugada Syndrome")
            
        # Handle Normal case
        if not readable_labels and self.dataset_source == DatasetSource.BRUGADA_HUCA and self.brugada == 0:
            readable_labels.append("Normal ECG")
            
        return readable_labels


class ECGSample(BaseModel):
    """Complete ECG sample for model input with Multi-Task Learning support."""
    model_config = ConfigDict(arbitrary_types_allowed=True)
    
    signal: torch.Tensor  # Shape: (n_leads, n_samples)
    
    # Multi-Task Labels
    label_superclass: torch.Tensor  # Multi-hot (5 classes)
    label_subclass: torch.Tensor    # Multi-hot (23 classes) - placeholder
    label_brugada: torch.Tensor     # Binary (1 class)
    
    patient_id: str
    source: DatasetSource
    original_metadata: ECGMetadata
    
    # For debugging/visualization
    readable_label: List[str] = Field(default_factory=list)


class AugmentationConfig(BaseModel):
    """ECG signal augmentation configuration."""
    
    amplitude_scale_range: tuple[float, float] = (0.8, 1.2)
    amplitude_scale_prob: float = 0.3
    noise_std: float = 0.05
    noise_prob: float = 0.3
    baseline_wander_amplitude: float = 0.1
    baseline_wander_frequency: tuple[float, float] = (0.1, 0.5)
    baseline_wander_prob: float = 0.2
    time_warp_sigma: float = 0.2
    time_warp_knots: int = 4
    time_warp_prob: float = 0.15
    lead_scale_range: tuple[float, float] = (0.9, 1.1)
    lead_scale_prob: float = 0.2
    
    # Lead masking for robustness to missing leads
    lead_masking_prob: float = 0.3
    lead_masking_max_leads: int = 6  # Maximum number of leads to mask (keep at least 6)


class DataConfig(BaseModel):
    """Unified data configuration for multi-dataset training."""
    
    # Dataset Paths
    brugada_metadata_path: Optional[Path] = None
    brugada_data_root: Optional[Path] = None
    ptbxl_metadata_path: Optional[Path] = None
    ptbxl_data_root: Optional[Path] = None
    ptbxl_scp_statements_path: Optional[Path] = None
    
    # Sampling
    target_sampling_rate: int = 500  # Hz
    target_length_seconds: float = 10.0  # Standardize to 10 seconds
    
    # Splits
    train_split: float = Field(default=0.7, ge=0.0, le=1.0)
    val_split: float = Field(default=0.15, ge=0.0, le=1.0)
    test_split: float = Field(default=0.15, ge=0.0, le=1.0)
    
    # Cross-validation
    n_folds: int = Field(default=5, ge=2)
    stratified: bool = True
    
    # Data loading
    batch_size: int = Field(default=32, ge=1)
    num_workers: int = Field(default=4, ge=0)
    pin_memory: bool = True
    
    # Preprocessing
    normalize: bool = True
    normalization_method: str = "standardize"
    
    # Augmentation
    augment_train: bool = True
    augment_val: bool = False
    
    # Dataset mixing
    use_brugada: bool = True
    use_ptbxl: bool = True
    ptbxl_sampling_ratio: float = 1.0  # Downsample PTB-XL if needed
    
    # Reproducibility
    random_seed: int = 42
    
    @field_validator('brugada_metadata_path', 'ptbxl_metadata_path', mode='before')
    @classmethod
    def convert_path(cls, v):
        return Path(v) if isinstance(v, str) and v else v


class DatasetStatistics(BaseModel):
    """Multi-dataset statistics."""
    
    # Overall
    total_samples: int
    
    # By source
    brugada_samples: int = 0
    ptbxl_samples: int = 0
    
    # By superclass
    normal_samples: int = 0
    mi_samples: int = 0
    sttc_samples: int = 0
    cd_samples: int = 0
    hyp_samples: int = 0
    brugada_positive_samples: int = 0
    
    # Class weights
    superclass_weights: Dict[str, float] = Field(default_factory=dict)
    brugada_pos_weight: float = 1.0
    
    @classmethod
    def from_metadata_list(cls, metadata_list: List[ECGMetadata]) -> "DatasetStatistics":
        """Compute statistics from unified metadata."""
        total = len(metadata_list)
        
        # Count by source
        brugada_count = sum(1 for m in metadata_list if m.dataset_source == DatasetSource.BRUGADA_HUCA)
        ptbxl_count = sum(1 for m in metadata_list if m.dataset_source == DatasetSource.PTB_XL)
        
        # Count by superclass
        normal_count = sum(1 for m in metadata_list if DiagnosticSuperclass.NORM in m.diagnostic_superclass)
        mi_count = sum(1 for m in metadata_list if DiagnosticSuperclass.MI in m.diagnostic_superclass)
        sttc_count = sum(1 for m in metadata_list if DiagnosticSuperclass.STTC in m.diagnostic_superclass)
        cd_count = sum(1 for m in metadata_list if DiagnosticSuperclass.CD in m.diagnostic_superclass)
        hyp_count = sum(1 for m in metadata_list if DiagnosticSuperclass.HYP in m.diagnostic_superclass)
        
        # Count Brugada positive
        brugada_pos = sum(1 for m in metadata_list if m.brugada is not None and m.brugada >= 1)
        
        # Compute pos_weight per class for BCEWithLogitsLoss
        # pos_weight = n_negative / n_positive (how much more to weight positives)
        superclass_weights = {}
        for name, count in [("NORM", normal_count), ("MI", mi_count), ("STTC", sttc_count), 
                            ("CD", cd_count), ("HYP", hyp_count)]:
            if count > 0:
                neg_count = total - count
                superclass_weights[name] = neg_count / count  # Correct BCE pos_weight
            else:
                superclass_weights[name] = 1.0
        
        # Brugada pos weight
        brugada_neg = total - brugada_pos
        brugada_pos_weight = brugada_neg / brugada_pos if brugada_pos > 0 else 1.0
        
        return cls(
            total_samples=total,
            brugada_samples=brugada_count,
            ptbxl_samples=ptbxl_count,
            normal_samples=normal_count,
            mi_samples=mi_count,
            sttc_samples=sttc_count,
            cd_samples=cd_count,
            hyp_samples=hyp_count,
            brugada_positive_samples=brugada_pos,
            superclass_weights=superclass_weights,
            brugada_pos_weight=brugada_pos_weight
        )
